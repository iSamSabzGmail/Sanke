const boardSize = 20;
const board = document.getElementById("game-board");
const scoreEl = document.getElementById("score");
const statusEl = document.getElementById("status");

const overlay = document.getElementById("overlay");
const finalScoreEl = document.getElementById("final-score");
const retryBtn = document.getElementById("retry-btn");
const endBtn = document.getElementById("end-btn");

let snake, direction, apple, gift, giftTimer;
let score, speed, gameInterval, isPaused, gameOverState, applesEaten;

// Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ù„Ù…Ø³ÛŒ
let touchStartX = 0;
let touchStartY = 0;

function initGame() {
  snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }];
  direction = { x: 0, y: 0 };
  apple = randomApple();
  gift = null;
  giftTimer = null;
  score = 0;
  speed = 200; // Ú©Ù…ÛŒ Ø³Ø±ÛŒØ¹â€ŒØªØ± Ø¨Ø±Ø§ÛŒ Ú†Ø§Ù„Ø´ Ø¨ÛŒØ´ØªØ±
  applesEaten = 0;
  isPaused = true;
  gameOverState = false;
  scoreEl.textContent = "Score: 0";
  // Ù¾ÛŒØ§Ù… Ø´Ø±ÙˆØ¹ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ Ù¾Ù„ØªÙØ±Ù…
  statusEl.textContent = "Swipe or use arrow keys to start";
  clearInterval(gameInterval);
  createBoard();
  draw();
}

function createBoard() {
  board.innerHTML = "";
  for (let y = 0; y < boardSize; y++) {
    for (let x = 0; x < boardSize; x++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      board.appendChild(cell);
    }
  }
}

function draw() {
  const cells = board.querySelectorAll(".cell");
  cells.forEach(c => (c.className = "cell"));

  const appleIndex = apple.y * boardSize + apple.x;
  cells[appleIndex].classList.add("apple");

  if (gift) {
    const giftIndex = gift.y * boardSize + gift.x;
    cells[giftIndex].classList.add("gift");
  }

  snake.forEach((part, i) => {
    const idx = part.y * boardSize + part.x;
    if (cells[idx]) {
      cells[idx].classList.add("snake");
      if (i === 0) cells[idx].classList.add("head");
    }
  });
}

function randomApple() {
  let pos;
  do {
    pos = { x: Math.floor(Math.random() * boardSize), y: Math.floor(Math.random() * boardSize) };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y) || (gift && gift.x === pos.x && gift.y === pos.y));
  return pos;
}

function randomGift() {
  let pos;
  do {
    pos = { x: Math.floor(Math.random() * boardSize), y: Math.floor(Math.random() * boardSize) };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y) || (apple.x === pos.x && apple.y === pos.y));
  return pos;
}

function moveSnake() {
  const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

  if (head.x < 0 || head.x >= boardSize || head.y < 0 || head.y >= boardSize || snake.some(s => s.x === head.x && s.y === head.y)) {
    triggerGameOver();
    return;
  }

  snake.unshift(head);

  if (head.x === apple.x && head.y === apple.y) {
    score += 5;
    applesEaten++;
    speed *= 0.95; // Ø§ÙØ²Ø§ÛŒØ´ Ø³Ø±Ø¹Øª
    apple = randomApple();
    scoreEl.textContent = `Score: ${score}`;
    restartLoop();
    if (applesEaten % 3 === 0) spawnGift();
  } else if (gift && head.x === gift.x && head.y === gift.y) {
    score += 20;
    gift = null;
    clearTimeout(giftTimer);
    scoreEl.textContent = `Score: ${score}`;
  } else {
    snake.pop();
  }

  draw();
}

function spawnGift() {
  gift = randomGift();
  draw();
  clearTimeout(giftTimer);
  giftTimer = setTimeout(() => { gift = null; draw(); }, 5000);
}

function restartLoop() {
  clearInterval(gameInterval);
  gameInterval = setInterval(moveSnake, speed);
}

function pauseGame() {
  if (gameOverState) return;
  if (isPaused) {
    isPaused = false;
    restartLoop();
    statusEl.textContent = "Press SPACE to pause";
  } else {
    isPaused = true;
    clearInterval(gameInterval);
    statusEl.textContent = "â¸ Paused (Press SPACE to resume)";
  }
}

function triggerGameOver() {
  clearInterval(gameInterval);
  clearTimeout(giftTimer);
  gameOverState = true;
  isPaused = true;
  statusEl.textContent = "ğŸ’€ Game Over!";
  finalScoreEl.textContent = `Your score: ${score}`;
  overlay.classList.remove("hidden");
}

// ØªØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± Ø¬Ù‡Øª Ø¬Ù‡Øª Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ú©Ø¯ ØªÚ©Ø±Ø§Ø±ÛŒ
function changeDirection(newDir) {
  if (snake.length > 1 && newDir.x === -direction.x && newDir.y === -direction.y) return;
  direction = newDir;
  startGame();
}

function startGame() {
  if (gameOverState) return;
  if (!isPaused) return;
  isPaused = false;
  statusEl.textContent = "Press SPACE to pause";
  restartLoop();
}

// --- Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ù„Ù…Ø³ÛŒ (Ø¨Ø±Ø§ÛŒ Ù…ÙˆØ¨Ø§ÛŒÙ„) ---
function handleTouchStart(e) {
  e.preventDefault(); // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§Ø³Ú©Ø±ÙˆÙ„ ØµÙØ­Ù‡
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}

function handleTouchEnd(e) {
  if (!touchStartX || !touchStartY) return;
  e.preventDefault(); // Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø§Ø³Ú©Ø±ÙˆÙ„ ØµÙØ­Ù‡

  let touchEndX = e.changedTouches[0].clientX;
  let touchEndY = e.changedTouches[0].clientY;

  let dx = touchEndX - touchStartX;
  let dy = touchEndY - touchStartY;

  if (Math.abs(dx) > Math.abs(dy)) { // Ø­Ø±Ú©Øª Ø§ÙÙ‚ÛŒ
    if (dx > 0) changeDirection({ x: 1, y: 0 }); // Ø±Ø§Ø³Øª
    else changeDirection({ x: -1, y: 0 }); // Ú†Ù¾
  } else { // Ø­Ø±Ú©Øª Ø¹Ù…ÙˆØ¯ÛŒ
    if (dy > 0) changeDirection({ x: 0, y: 1 }); // Ù¾Ø§ÛŒÛŒÙ†
    else changeDirection({ x: 0, y: -1 }); // Ø¨Ø§Ù„Ø§
  }
  touchStartX = 0;
  touchStartY = 0;
}

// Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù„Ù…Ø³ÛŒ Ø¨Ù‡ ØµÙØ­Ù‡ Ø¨Ø§Ø²ÛŒ
board.addEventListener('touchstart', handleTouchStart, { passive: false });
board.addEventListener('touchend', handleTouchEnd, { passive: false });


// --- Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ Ú©ÛŒØ¨ÙˆØ±Ø¯ (Ø¨Ø±Ø§ÛŒ Ø¯Ø³Ú©ØªØ§Ù¾) ---
document.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();
  if (key === " " || key === "spacebar") {
    pauseGame();
    return;
  }
  const dirMap = {
    arrowup: { x: 0, y: -1 }, w: { x: 0, y: -1 },
    arrowdown: { x: 0, y: 1 }, s: { x: 0, y: 1 },
    arrowleft: { x: -1, y: 0 }, a: { x: -1, y: 0 },
    arrowright: { x: 1, y: 0 }, d: { x: 1, y: 0 },
  };
  if (dirMap[key]) {
    changeDirection(dirMap[key]);
  }
});

// Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ø§Ù¾ Ø¢Ù¾
retryBtn.addEventListener("click", () => {
  overlay.classList.add("hidden");
  initGame();
});

endBtn.addEventListener("click", () => {
  overlay.classList.add("hidden");
  statusEl.textContent = "Game ended. Refresh to play again.";
  gameOverState = true;
});

// Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
initGame();
